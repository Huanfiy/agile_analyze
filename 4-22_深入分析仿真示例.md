# 深入分析agile_autonomy项目给的仿真测试

![a1d612d6cfaf63f2088fdd8c1ecfe358](./image/a1d612d6cfaf63f2088fdd8c1ecfe358.png)

[在项目介绍页](https://github.com/uzh-rpg/agile_autonomy/)，得知在另一个terminal中运行此命令：会启动飞机进行避障飞行

```bash
python test_trajectories.py --settings_file=config/test_settings.yaml
```

在[源码裁剪](./源码裁剪.md)中，分析了该命令运行后主要启动一个函数：*trainer.perform_testing()*	，分析知该函数与飞机进行避障飞行有关，

现在对该函数深入分析。



### 4.24 分析test_trajectories.py

```python
def main():
    parser = argparse.ArgumentParser(description='Evaluate Trajectory tracker.')
    parser.add_argument('--settings_file', help='Path to settings yaml', required=True)

    args = parser.parse_args()
    settings_filepath = args.settings_file
    settings = create_settings(settings_filepath, mode='test')
    trainer = Trainer(settings)
    trainer.perform_testing()
```

该文件加载 *test_settings.yaml* 并创建了 *Trainer* 类实例，执行该类的 *perform_testing()* 方法。

在 *dagger_training.py* 中，

```py
    def __init__(self, settings):
        rospy.init_node('iterative_learning_node', anonymous=False)
        self.settings = settings
        np.random.seed(self.settings.random_seed)
        self.expert_done = False
        self.label_sub = rospy.Subscriber("/hummingbird/labelling_completed", Bool,
                                          self.callback_expert, queue_size=1)  # Expert is done, decide what to do.
        self.msg_handler = MessageHandler()
```

（可以看出以 *Trainer* 创建实例时会创建一个 ***'iterative_learning_node'*** 节点）



####  *perform_testing()* 

```py
    def perform_testing(self):
        self.learner = PlannerLearning.PlanLearning(
            self.settings, mode="testing")
        tree_spacings = self.settings.tree_spacings
        removable_rollout_folders = os.listdir(self.settings.expert_folder)
        if len(removable_rollout_folders) > 0:
            removable_rollout_folders = [os.path.join(self.settings.expert_folder, d) \
                                         for d in removable_rollout_folders]
            removable_rollout_folders = [d for d in removable_rollout_folders if os.path.isdir(d)]
            for d in removable_rollout_folders:
                string = "rm -rf {}".format(d)
                os.system(string)
```

该函数**首先**初始化了一个 *PlanLearning* 对象实例，**然后**从settings对象属性里获取了一些值，**删除**了一些文件 *removable_rollout_folders*

**最后开始循环**。

```python
for spacing in tree_spacings:
    ~
```

从以上分析总结四点下一步要进行的工作：

- 分析 **PlanLearning**
- 了解 **settings对象**
- 为什么删除 **removable_rollout_folders**
- 循环体做了什么事



### 4.25 分析test_trajectories.py

*perform_testing()* 函数中的 **settings对象** 即此命令中加载的 **test_settings.yaml** 文件，

```bash
python test_trajectories.py --settings_file=config/test_settings.yaml
```

 **settings对象** 定义在 *config/* 目录下的 **settings.py** 中，

```py
        for spacing in tree_spacings:
            self.msg_handler.publish_tree_spacing(spacing)
            self.msg_handler.publish_obj_spacing(spacing)
            exp_log_dir = os.path.join(self.settings.log_dir, "tree_{}_obj_{}".format(spacing,spacing))
            os.makedirs(exp_log_dir)
            # Start Experiment
            rollout_idx = 0
            report_buffer = []
            while rollout_idx < self.settings.max_rollouts:
                self.learner.maneuver_complete = False  # Just to be sure
                unity_start_pos = setup_sim(self.msg_handler, config=self.settings)
                self.start_experiment(rollout_idx)
                output_file_buffer = os.path.join(exp_log_dir,
                                                "experiment_metrics.json")
                start = time.time()
                exp_failed = False
                self.expert_done = False  # Re-init to be sure
```

![](./image/129e0ba8283b6fb08ab446a3790686ef.png)

由配置文件可知，for循环只执行了一遍，发布消息生成对应数量的树和物体

```py
self.msg_handler.publish_tree_spacing(spacing)
self.msg_handler.publish_obj_spacing(spacing)
```

